#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;

double f(double x) // объявляем нашу подинтегральную функцию.
{
	return 1.0 / ( sqrt(2*pow(x, 2) + 1) );
}
// объявляем функцию которая вычисляет интеграл методом Симпсона
// a  - левая граница
// b  - правая граница
// n  - количество разбиений отрезка, по которому берем интеграл
// *f - указатель на  подинтегральную функцию
double SimpsonMethod(double a, double b, int n, double (*f)(double x)) 
{
	double h = (b - a) / n;	// вычисляем шаг - h
	double sum = 0;		// сумма, результат вычисления интеграла.
	double x0 = a;		// правая граница подотрезка отрезка [a, b]
	double x1 = a + h;	// левая граница подотрезка отрезка [a, b]

	for (int i = 0; i < n; i++) // в цикле применяем формулу Симпсона
	{
        	sum += f(x0) + 4*f(x0 + h/2) + f(x1);	//для каждого подотрезка, и складываем все полученные значения в общую сумму.
        	x0 += h;	// сдвигаем левую и
        	x1 += h;	// правую границу, иначе говоря меняем подотрезок отрезка [a, b]
	}

	return (h/6)*sum;	// возвращаем сумму умноженную на (h/6)(по формуле), т.к. (h/6) общий множитель который можно вынести за скобки.
}
int main()
{
	double a = 0.8;
	double b = 1.6;
	int n;
	cout << "Enter n: "; cin >> n;
	cout << setprecision(15); //точность вывода.
	cout << "S = " << SimpsonMethod(a, b, n, f) << endl;
	system("pause");
	return 0;
}